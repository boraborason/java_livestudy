# 목표

자바의 상속에 대해 학습하세요.

# 학습할 것 (필수) 

- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스

## 자바 상속의 특징

**상속** 이란기존의 클래스를 재사용 하여 새로운 클래스를 작성하는 것이다.

**상속** 을 통해 클래스를 작성하면 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리 할 수 있기 때문에 코드의 추가 및 변경이 용이하다. 

<img src="https://user-images.githubusercontent.com/57280699/102821202-0645ac80-441a-11eb-8700-c9bad5245c5e.png" alt="image" style="zoom:67%;" />

- 생성자와 초기화 블럭은 상속되지않는다.

- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

- 접근제어자가 private, default인 멤버들은 상속은 받지만 자손클래스로부터 접근이 제한된다.

- 자손클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스가 생성된다. 

  

## super 키워드

### super

- **super**은 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.(  조상클래스로부터 상속받은 멤버 변수를 가리킨다.)

  -> 멤버변수와 지역변수의 이름이 같은 때 this를 붙어 구별했듯이 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 땐 super를 붙여 구별한다.

  ​    모든 인스턴스 메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데 이것이 참조변수인 this와 super값이 된다.

  

- **super**은 변수만이 아니라 메서드 역시 호출 할 수 있다. 특히 조상 클래스의 메서드를 자손 클래스에서 오버라이딩 한 경우에 super을 사용한다.  



### super()

this()와 마찬가지로 super()역시 생성자 이다.  this는 같은 클래스의 다른 생성자를 호출하지만 super()은 조상 클래스의 생성자를 호출하는데 사용된다.



## 메소드 오버라이딩

**오버라이딩**이란 조상 클래스로부터 상속받은 메서의 내용을 변경하는 것이다.

상속받은 메서드를 그대로 사용하기도 하지만 자손 클래스에 맞게 변경하기도 한다. 



**오버라이딩의 조건**

자손 클래스에서 오버라이딩하는 메서드의 조상 클래스의 메서드와

- 이름이 같아야한다.

- 매개변수가 같아야 한다.

- 반환타입이 같아야한다. (JDK1.5부터 반환타입을 자손 클래스 타입으로 변경 가능)

  

다만, 접근제어자와 예외는 제한된 조건 하에서만 다르게 변경가능하다.

1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 불가능

2. 조상 클래스의 메서드보다 많은 수의 예외를 선언 할 수 없다. (갯수x)
3. 인스턴스 메서드를 static메서드 또는 그 반대로 변경 할 수 없다.



**오버라이딩** vs **오버로딩**

오버라이딩 : 조상클래스의 메서드를 자손클래스에서 재정의 하여 사용

오버로딩 :  기존에 없는 메서드를 추가하는 것이다. (이름은 같음)  



## 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)

디스패치는 어떤 메소드를 호출할 것인가를 결정하여 그것을 실행하는 과정이다. 

동적 디스패치와 정적 디스패치가 있는데, **동적 디스패치**(dynamic dispatch)는 메소드 오버라이딩이 되어있는 경우 **런타임**에 어떤 메소드를 실행할 지 결정되는 것이다. 정적 디스패치는 그와 다르게 **컴파일 시점**에 어떤 메소드를 실행할지 결정된다.



## 추상 클래스

### 추상클래스란?

 A클래스, B클래스, C클래스가 있다고 가정할 때 각 클래스 안에는 각자의 필드와 메서드가 있을것이다. **추상클래스는 A클래스, B클래스, C클래스들 간에 비슷한 필드와 메서드를 공통적으로 추출해 만들어진 클래스다.**

실체클래스는 실체가 드러나는 클래스...추상클래스는 실체 클래스의 공통적인 부분을 추출해 어느정도 규격을 잡아놓은 추상적인 클래스이다. 그래서 실체클래스 실제 객체를 생성할 정도의 구체성을 가지는 반면! 추상클래스는 아직 메서드와 내용이 추상적이기 때문에 **객체를 생성할 수 없게 만들었다**

**추상클래스와 실체클래스는 상속적인 관계**를 가지고 있다.



1. 추상클래스는 뭐? 실체클래스의 공통적인 부분(변수,메서드)를 추출해서 선언한 클래스

2. 추상클래스는 객체를 생성할 수 없다! 아직은 실체성이 없고 구체적이지 않기 때문에!

3. 추상클래스와 실체클래스는 어떤관계? 상속관계!

 

### 추상클래스는 왜 사용할까?

1. 공통된 필드와 메서드를 통일할 목적

   추상클래스에서 미리 정의한 필드와 메서드가 있다면, 실체클래스는 추상클래스의 필드와 메서드명을 변경할 수 없고 무조건 해당 명명으로 구현해야한다. 따라서, **필드와 메서드 이름을 통일하여 유지보수성을 높이고 통일성을 유지**할 수 있다.

   

2. 실체클래스 구현시 시간절약

   추상클래스를 상속받아 강제로 주어지는 필드와 메서드를 가지고 나만의 스타일대로 구현만 하면 된다. 설계 시간이 절약된다..구현하는데만 집중할 수 있다 

   

3. 규격에 맞는 실체 클래스 구현

   개발은 혼자 하는 일이 아니므로 자기 스타일대로 구현한다고 해도 규격을 벗어나면 안된다. 추상 클래스를 상속 받은  실체클래스들은 반드시 추상메서드를 오버라이딩(재정의) 해서 작성을 해야 하므로 규격을 맞춰준다.

## final 키워드

자바에서 final키워드는 상수를 표현하기 위한 예약어 이다. 

변수, 메서드, 클래스에서 모두 이용되고 있는데 **final변수**의경우 값을 수정 할 수 없으며 **final메서드** 는 오버라이딩이 불가능하며 상속받은 그대로 사용해야 한다.                         **final클래스**는 상송이 불가능 하다.



## Object 클래스

java.lang패키지는 자바프로그래밍에서 가장 기본이 되는 클래스를 포함하고 있으며 import문이 없어도 사용 할 수 있게 되어있다.  

java.lang패키지 클래스 중에서도 **Object클래스**는 모든 클래스의 최고 조상으로 **Object클래스**의 멤버들은 모든 클래스에서 바로 사용이 가능하다.



이 중 중요한 몇가지를 살펴보자

1. **equals(Object obj)**

   equals는 **내용이 같은지**를 검사하는 메서드다.

   명확하게는 default로 primitive type은 내용이 같은지 검사하고, reference type은 객체의 주소가 같은지 검사한다.

   ```java
   String str1 = "hello";
   String str2 = "hello";
   System.out.println(str1.equals(str2));//true
   String str3 = new String("hello");
   String str4 = new String("hello");
   System.out.println(str3.equals(str4));//true
   
   //'==' 연산자와 다른 점은 완전히 같은 객체를 가리키지 않아도 개발자가 true로 만들 수 있다.(String 클래스만 가능, equals() 메소드가 이미 오버라이딩 되어있음)
   ```

str1과 str2는 같은 주소를 가리키고 있을 뿐만아니라 **내용(값)도 같으므로** equals메서드의 결과 true를 리턴한다.

str3과 str4는 가리키는 주소는 달라도 내용(값)이 같으므로 equals메서드의 결과 true를 리턴한다.

자바에서 String 클래스 내부적으로 equals메서드를 오버라이드(재정의) 해서 이런 결과가 나타난 것으로 **String클래스가 아닌 개발자가 생성한 클래스의 객체는 자바가 내용이 같은지를 판단하기는 어렵다.** 



참고 **== 연산자**

== 연산자는 **피연산자가 primitive type(int, double, boolean, ...)일 때는 값이 같은지** 비교하고, 피연산자가 그 외 객체, reference type일 때 가리키는 **주소가 같은지**를 검사한다.

'==' 연산자는 두 객체가 같은 것을 가리킬 때만 true를 준다

```java
String str1 = "hello";
String str2 = "hello";
System.out.println(str1 == str2);//true
String str3 = new String("hello");
String str4 = new String("hello");
String str5 = str4;
System.out.println(str3 == str4);//false equals로 비교했다면 true!
System.out.println(str4 == str5);//true
```





2. **hashCode**()

   hachCode()는 객체의 hashCode를 리턴하는 메서드로 hashCode는 **객체의 주소값을 변환하여 생성한 객체의 고유한 정수 값**을 말한다. 따라서 두 객체가 동일한 객체인지 비교할 때 사용한다.

   JVM의 heap 영역의 인스턴스에 대한 참조값을 주는 방식이 hash 방식으로 Key-Value 쌍으로 객체를 보관한다. 

   예를들어, 책에 index가 바로 hash 방식이다. 찾고자 하는 단어가 key가 될 것이고, 그 내용이 있는곳을 index가 가리켜 준다. index에 있는 쪽 수를 따라가보면 원하는 내용을 찾을 수 있다. (**Key의 hashcode를 통해 Value값을 더 쉽게 찾아낼 수 있다**)

<img src="https://user-images.githubusercontent.com/57280699/103071542-21c1da80-4607-11eb-9aab-869565ea61bc.png" alt="image" style="zoom: 67%;" />

equals()메서드와 마찬가지로 String 클래스는 문자열의 내용이 같으면, 동일한 해시코드를 반환하도록 hashCode메서드가 오버라이딩 되어있다. 때문에 문자열의 내용이 같은 str1과 str2 에대해 hashCode()를 호출하면 true를 반환한다.

identityHashCode는 모든 객체에 대해 항상 다른 해시코드값을 반환할 것을 보장하기 때문에 다른값이 출력된다.



2. **toString**()

   이 메서드는 인스턴스에 대한 정보를 문자열로 표현한다. 단지 Object클래스 toString클래스는 의미없는 디폴트 값만 출력해준다.

   메서드를 재정의 하여 의미 있는 값을 리턴할 수 있는데  **"String"클래스** 객체의 "toString"메소드는 문자열을 리턴하고,  **"File"클래스** 객체의 "toString"메소드는 자신이 가진 해당 경로값을 리턴해 준다.



2. **clone**()

   이 메서드는 자신을 복제하여 새로운 인스턴스를 생성하는 일을 한다. 

   ※ 복제이유: 원본객체를 안전하게 보호하기 위해서
   ※ cloneable 인터페이스를 구현하지 않으면 clone()메소드를 호출할 때 CloneNotSupportedException예외가 발생( try-catch 구문 필요)
   ※ 얕은복제(this clone)와 깊은복제(deep clone)가있음

   

   복제를 하기 위해서는 Cloneable 인터페이스를 구현한뒤 clone메서드를 재정의 해야한다. 상위클래스의 clone을 복제하여  rerurn하여 연결시켜주면 끝! 

   ​     (대신 CloneNotSupportedException 예외를 밖으로 던져주는 부분포함!)

   ![image](https://user-images.githubusercontent.com/57280699/103208052-16dab300-4943-11eb-84e1-4ee68ed7b1e0.png)

   

   

3. **getClass**()

   이 메서드는 자신이 속한 클래스의 Class객체를 반환하는 메서드이다.

   Class객체는 클래스의 모든 정보를 담고 있으며 클래스당 1개만 존재하고 클래스 파일이 '클래스로더'에 의해 메모리에 올라갔을 때 자동으로 생성된다. 

Class객체를 얻는 방법

```java
Class a = new Car().getClass(); //생성된 객체로 부터 얻는 방법
Class a = Car.Class;			//클래스 리터럴(*.class)로부터 얻는 받법
Class a = Class.forName("Car"); //클래스 이름으로 부터 얻는 방법
```

 Class.forName은 특정 클래스 파일 주로 db드라이버를 메모리에 올릴 때 사용한다.