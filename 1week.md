# 1주차 과제

## 목표

- #### 자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.

## 학습할 것

- ##### JVM이란 무엇인가

- ##### 컴파일 하는 방법

- ##### 실행하는 방법

- ##### 바이트코드란 무엇인가

- ##### JIT 컴파일러란 무엇이며 어떻게 동작하는지

- ##### JVM 구성 요소

- ##### JDK와 JRE의 차이



### JVM이란 무엇인가

JVM이란 자바를 실행하기위한 가상 프로그램이다. 

자바로 작성된 프로그램은 운영체제가 아닌 JVM에서만 실행되는데 JVM만 각 OS에 설치되어 있다면 OS마다 따로 코드를 작성해야 하는 번거로움 없이 java가 **플랫폼에 독립적** 일 수 있게 해준다.

![image](https://user-images.githubusercontent.com/57280699/101924825-78491500-3c14-11eb-9fac-2de47403d36e.png)

### 컴파일 하는 방법

개발자가 작성하는 ~.java 파일을 **컴파일러**가 바이트 코드를 생성하여 ~.class 파일로 만들어 

자바 파일을 실행가능한 class파일 상태로 컴파일 한다. 



### 실행하는 방법

1. java 클래스 파일을 class loader가 모아서 Runtime Data Area 로 적재한다.

2. 메모리에 적재된 class파일들을 Execution Engine이 기계어로 변경해 단위실행한다.

   (2가지 방식 - 인터프리터 방식,  JIT(Just In Time compiler)방식 )

   

### 바이트코드란 무엇인가

JVM이 이해할 수 있는 언어로 변환된 자바 소스코드를 말한다. 

이러한 바이트 코드의 확장자는 .class이며 JVM만 설치되어있으면 어떤 OS에서 라도 실행 될 수 있다.



### JIT 컴파일러란 무엇이며 어떻게 동작하는지

java에서 Compile 을 하면 Bytecode 로 변환되는데 이 바이트코드는 실제 실행될 때 다시 한번 기계가 읽을 수 있는 형태(native code)로 interpreter 를 통해 해석이 되어야 하는데 느리다는 단점을 보완하기 위해 jit방 방식이 나왔다.

**JIT방식** :  JIT 방식은 실행 시점에 자주 쓸만한 코드들을 기계어로 변환 시켜놓고 저장해 뒀다가, 재사용 할 때 이미 변환된 기계어 코드를 재 사용 하는 방식을 말한다. 물론 이 과정을 하기 위해 초반에 메모리를 잡아두거나 하는 선행 작업들이 있어서 초기 실행 속도는 다소 느릴 수도 있지만  이후 ByteCode를 사용 할 때마다 네이티브 코드로 변환하는 작업이 들어 실행속도가 많이 향상된다. 



**인터프리터 방식** : 명령어를 하나씩 수행(기본적인 방식. 전체 수행은 느리나 명령어 하나씩의 동작은 빠름)

### JVM 구성 요소

jvm은 크게 4가지로 구성된다.

1. ###### Class Loader

   class파일들을 모아서 JVM이 운영체로부터 할당받은 메모리 영역인 Runtime Data Area로 적재하는 역할을 한다

2. ###### Execution Engine

   메모리에 적재된 class파일들을 Execution Engine이 기계어로 변경해 단위실행한다.

3. ###### Garbage Collector

   Garbage Collector는 Heap 메모리 영역에 생성된 객체들 중에 참조되지 않은 객체들을 제거하는 역할을 한다.

4. ###### Runtime Data Area

   JVM의 메모리 영역으로 자바 애플리케이션 실행시 사용되는 데이터를 적재하는 영역이다.
   크게 5가지 영역으로 구분된다.

   

   > **1. Method Area**
   > 필드 정보(클래스 멤버 변수명, 데이터 타입, 접근 제어자 정보)
   > 메소드 정보(메소드명, 리턴 타입, 접근 제어자 정보)
   > Type 정보(Interface인지 Class인지)
   > Constant Pool(상수 풀: 문자 상수, 타입, 필드, 객체 참조 저장)
   > static 변수
   > final 클래스 변수

   > **2. Heap Area**
   > new 키워드로 생성된 객체와 배열이 생성되는 영역
   > Method Area에 로드된 class만 생성 가능하며 GC가 참조되지 않은 메모리를 확인하고 제거하는 영역

   > **3. Stack Area**
   > 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시값 등을 저장
   > int a = 10 을 예로 들면 정수값이 할당될 수 있는 메모리 공간을 a라고 잡아두고 그 메모리 영역에 10을 넣는다.
   > 클래스 A a = new A()의 경우 A a는 스택영역에 저장되고 new로 생성된 A클래스의 인스턴스는 Heap영역에 생성된다.
   > 또한 스택영역에 생성된 a는 힙영역의 주소값을 가지고 있다. 즉 a가 heap영역에 생성된 객체를 가리키며 참조하고 있다.
   > 메소드 호출시마다 개별적으로 스택이 생성된다.

   > **4. PC Register**
   > Thread가 생성될 때마다 생성되는 영역으로 Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. 이것을 이용해 쓰레드를 돌아가면서 수행한다

   > **5. Native Method Stack**
   > 자바외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다
   > 보통 C/C++등의 코드를 수행하기 위한 스택이다 (JNI)

   출처 : https://velog.io/@hono2030/JVM%EC%9D%98-%EA%B5%AC%EC%A1%B0

### JDK와 JRE의 차이

<img src="https://user-images.githubusercontent.com/57280699/101934637-37a3c880-3c21-11eb-9b2b-e5eca58a2546.png" alt="image" style="zoom:67%;" />

**JDK란?**

JDK는 Java Development Kit의 약자로 말그대로 자바 개발시 필요한 도구를 제공하는 모음이다.    JDK 안에는 JRE가 포함되어 있다. 

**JRE란?**

먼저 JRE는 Java Runtime Environment의 약자로 자바 프로그램을 실행시켜주는 환경을 구성해주는 도구다. 즉 JAVA를 개발할 필요는 없는데, 실행은 시켜줘야 하는 경우에는 꼭 JRE가 있어야 한다. 반면 JAVA 개발시 꼭 필요한 것이 있는데 그것이 바로 JDK다.

